<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="https://au1996.github.io/interview/css/index.css" />
  </head>
  <body>
    <p>
      <a href="https://juejin.cn/post/6844904063570542599" target="_blank" rel="noopener noreferrer"
        >文章链接</a
      >
    </p>
    <ol>
      <li>
        可进行链式调用，且每次 then 返回了新的
        Promise(2次打印结果不一致，如果是同一个实例，打印结果应该一致。
      </li>
      <li>
        只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由pending
        -> fulfilled或 pending-> rejected,是不可逆的
      </li>
      <li>then 中返回了新的 Promise,但是then中注册的回调仍然是属于上一个 Promise 的</li>
    </ol>
    <p>基于以上几点，我们先写个基于 PromiseA+ 规范的只含 resolve 方法的 Promise 模型</p>
    <script>
      function Promise(fn) {
        let state = 'pending'
        let value = null
        const callbacks = []

        this.then = function (onFulfilled) {
          return new Promise((resolve) => {
            handle({
              // 桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中
              onFulfilled,
              resolve,
            })
          })
        }

        function handle(callback) {
          if (state === 'pending') {
            callbacks.push(callback)
            return
          }

          if (state === 'fulfilled') {
            if (!callback.onFulfilled) {
              callback.resolve(value)
              return
            }

            const ret = callback.onFulfilled(value) // 处理回调
            callback.resolve(ret) // 处理下一个 promise 的resolve
          }
        }

        function resolve(newValue) {
          const fn = () => {
            if (state !== 'pending') return

            if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
              const { then } = newValue
              if (typeof then === 'function') {
                // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve
                // 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调
                then.call(newValue, resolve)
                return
              }
            }

            state = 'fulfilled'
            value = newValue
            handelCb()
          }

          setTimeout(fn, 0) //基于 PromiseA+ 规范
        }

        function handelCb() {
          while (callbacks.length) {
            const fulfiledFn = callbacks.shift()
            handle(fulfiledFn)
          }
        }

        fn(resolve)
      }
    </script>

    <script>
      new Promise((resolve) => {
        setTimeout(() => {
          resolve({ test: 1 })
        }, 1000)
      })
        .then((data) => {
          console.log('result1', data)
          //dosomething
          return test()
        })
        .then((data) => {
          console.log('result2', data)
        })

      function test(id) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve({ test: 2 })
          }, 3000)
        })
      }
    </script>
  </body>
</html>
