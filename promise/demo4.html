<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="https://au1996.github.io/interview/css/index.css" />
  </head>
  <body>
    <p>
      <a
        href="https://juejin.cn/post/6844904063570542599#heading-1"
        target="_blank"
        rel="noopener noreferrer"
        >文章链接</a
      >
    </p>
    <p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p>
    <p>
      入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为
      fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为
      fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有
      Promise 实例都执行完毕。
    </p>

    <p>
      有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise
      实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled
      的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise
      对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。

      <script>
        function Promise(fn) {
          let state = 'pending'
          let value = null
          const callbacks = []

          this.then = function (onFulfilled, onRejected) {
            return new Promise((resolve, reject) => {
              handle({
                onFulfilled,
                onRejected,
                resolve,
                reject,
              })
            })
          }

          this.catch = function (onError) {
            return this.then(null, onError)
          }

          this.finally = function (onDone) {
            return this.then(onDone, onDone)
          }

          this.resolve = function (value) {
            if (value && value instanceof Promise) {
              return value
            }
            if (value && typeof value === 'object' && typeof value.then === 'function') {
              const { then } = value
              return new Promise((resolve) => {
                then(resolve)
              })
            }
            if (value) {
              return new Promise((resolve) => resolve(value))
            }
            return new Promise((resolve) => resolve())
          }

          this.reject = function (value) {
            return new Promise((resolve, reject) => {
              reject(value)
            })
          }

          this.all = function (arr) {
            const args = Array.prototype.slice.call(arr)
            return new Promise((resolve, reject) => {
              if (args.length === 0) return resolve([])
              let remaining = args.length

              function res(i, val) {
                try {
                  if (val && (typeof val === 'object' || typeof val === 'function')) {
                    const { then } = val
                    if (typeof then === 'function') {
                      then.call(
                        val,
                        (val) => {
                          res(i, val)
                        },
                        reject
                      )
                      return
                    }
                  }
                  args[i] = val
                  if (--remaining === 0) {
                    resolve(args)
                  }
                } catch (ex) {
                  reject(ex)
                }
              }
              for (let i = 0; i < args.length; i++) {
                res(i, args[i])
              }
            })
          }

          this.race = function (values) {
            return new Promise((resolve, reject) => {
              for (let i = 0, len = values.length; i < len; i++) {
                values[i].then(resolve, reject)
              }
            })
          }

          function handle(option) {
            if (state === 'pending') {
              callbacks.push(option)
              return
            }

            const cb = state === 'fulfilled' ? option.onFulfilled : option.onRejected
            const next = state === 'fulfilled' ? option.resolve : option.reject

            // 没有回调函数的处理
            if (!cb) {
              next(value)
              return
            }

            // 处理报错
            try {
              const ret = cb(value)
              next(ret)
            } catch (e) {
              option.reject(e)
            }
          }

          function resolve(newValue) {
            const fn = () => {
              if (state !== 'pending') return

              if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                const { then } = newValue
                if (typeof then === 'function') {
                  // newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve
                  //相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调
                  then.call(newValue, resolve, reject)
                  return
                }
              }
              state = 'fulfilled'
              value = newValue
              handelCb()
            }

            setTimeout(fn, 0)
          }

          function reject(error) {
            const fn = () => {
              if (state !== 'pending') return

              if (error && (typeof error === 'object' || typeof error === 'function')) {
                const { then } = error
                if (typeof then === 'function') {
                  then.call(error, resolve, reject)
                  return
                }
              }
              state = 'rejected'
              value = error
              handelCb()
            }
            setTimeout(fn, 0)
          }

          function handelCb() {
            while (callbacks.length) {
              const fn = callbacks.shift()
              handle(fn)
            }
          }

          fn(resolve, reject)
        }
      </script>

      <script>
        new Promise((resolve, reject) => {
          setTimeout(() => {
            reject({ test: 'error' })
          }, 1000)
        })
          .then((data) => {
            console.log('then', data)
          })
          .catch((err) => {
            console.log('catch', err)
          })
          .finally(() => {
            console.log('finally')
          })
      </script>
    </p>
  </body>
</html>
